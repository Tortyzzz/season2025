#include <vector>
#include <cmath>
#include <iostream>
#include <utility> // для pair

using namespace std;

bool isPowerOfTwo(int n) {
    return (n & (n - 1)) == 0 && n != 0;
}

int calculateRedundantBits(int m) {
    int r = 0;
    while (pow(2, r) < m + r + 1) {
        r++;
    }
    return r;
}
// кодирование исходного слова
vector<int> generateHammingCode(const vector<int>& messageBits) {
    int m = messageBits.size(); // длина кодируемого слова
    int r = calculateRedundantBits(m); // количество проверочных битов
    int n = m + r; // итоговая длина кодируемого слова вместе с проверочными битами

    vector<int> hammingCode(n, 0);

    for (int i = 0; i < r; i++) { // цикл определения мест проверочных битов
        int pos = pow(2, i) - 1;
        if (pos < n) {
            hammingCode[pos] = -1; // для дальнейшего определения проверочных битов отделяем их.
        }
    }

    int messageIndex = 0;
    for (int i = 0; i < n; i++) { // определение информационных битов в закодированном слове
        if (hammingCode[i] != -1) {
            hammingCode[i] = messageBits[messageIndex++];
        }
    }

    for (int i = 0; i < r; i++) { // вычисление проверочных битов при помощи XOR
        int parityPos = pow(2, i) - 1;
        if (parityPos >= n) continue;

        int parity = 0;

        for (int j = parityPos; j < n; j++) {
            if ((((j + 1) >> i) & 1) && hammingCode[j] != -1) {
                parity ^= hammingCode[j];
            }
        }
        hammingCode[parityPos] = parity;
    }

    return hammingCode; // закодированные сообщение
}

pair<vector<int>, int> decodeHammingCode(vector<int> receivedCode) {
    int n = receivedCode.size();
    int r = 0;
    while (pow(2, r) < n + 1) { // проверка количества проверочных битов в переданом, закодированном слове
        r++;
    }

    int errorPos = 0;
    for (int i = 0; i < r; i++) { // определение синдрома
        int parityPos = pow(2, i) - 1;
        if (parityPos >= n) continue;

        int parity = 0;
        for (int j = parityPos; j < n; j++) {
            if ((((j + 1) >> i) & 1)) {     // если j-тый бит вляет на синдром то,
                parity ^= receivedCode[j];  // выполняем операцию XOR
            }
        }

        if (parity != 0) { // указание на место ошибки
            errorPos += parityPos + 1;
        }
    }

    if (errorPos > 0 && errorPos <= n) {    // исправление ошибки
        receivedCode[errorPos - 1] ^= 1;    // инвертация бита
    }

    vector<int> messageBits;
    for (int i = 0; i < n; i++) {
        if (!isPowerOfTwo(i + 1)) {     // извлечение информационных битов
            messageBits.push_back(receivedCode[i]); // добавление их в декодированное слово
        }
    }

    return make_pair(messageBits, errorPos); // исправленное сообщение и ошибка(если есть)
}

void printVector(const vector<int>& vec, const string& name) {
    cout << name << ": ";
    for (int bit : vec) {
        cout << bit << " ";
    }
    cout << endl;
}

int main() {
    setlocale(LC_ALL, "rus");

    vector<vector<int>> testMessages = {
        {1, 0, 1, 1},
        {1, 0, 1, 1, 0, 1, 0},
        {1, 0, 0, 1, 1},     
        {1, 1, 1, 0, 0, 0, 1, 1, 0, 1} 
    };

    for (int i = 0; i < testMessages.size(); i++) {
        cout << "Тест " << i + 1 << endl;
        printVector(testMessages[i], "Исходное сообщение");

        vector<int> hammingCode = generateHammingCode(testMessages[i]);
        printVector(hammingCode, "Закодированное сообщение для проверки ");

        vector<int> corruptedCode = hammingCode;
        if (hammingCode.size() > 2) {
            corruptedCode[4] ^= 1; // принудительная ошибка
            printVector(corruptedCode, "Принятый код  ");

            auto result = decodeHammingCode(corruptedCode);
            cout << "Ошибка в позиции: " << result.second << endl;
            printVector(result.first, "Исправленное сообщение");
            
        }

        cout << endl;
    }
}
